<?php namespace Steenbag\Tubes\WebService;
use Steenbag\Tubes\Descriptor\JsonDescriptor;
use Steenbag\Tubes\Transformer\Transformer;

/**
 * Class BaseService
 * @package Steenbag\Tubes\WebService
 */
class BaseService implements ServiceInterface
{

    protected static $name = '';

    protected static $description = '';

    protected static $thriftName = '';

    protected static $thriftServiceName = '';

    protected static $version = '0.1';

    protected $config = [];

    protected $enabled;

    public function __construct($enabled = true, array $config = [])
    {
        $this->enabled = $enabled;
        $this->initConfig($config);
    }

    /**
     * Return the name of this service.
     *
     * @return string
     */
    public static function getName()
    {
        return static::$name;
    }

    /**
     * Return the description of this service.
     *
     * @return string
     */
    public static function getDescription()
    {
        return str_replace('{TOOL_NAME}', \Config::get('app.name'), static::$description);
    }

    /**
     * Return the version of this service.
     *
     * @return mixed
     */
    public static function getVersion()
    {
        return static::$version;
    }

    /**
     * Return all of the methods that this service can respond to.
     *
     * @return array
     * @throws \ReflectionException
     */
    public static function listProcedures()
    {
        $reflector = new \ReflectionClass(new static);
        $methods = $reflector->getMethods(\ReflectionMethod::IS_PUBLIC);
        $_methods = [];
        foreach ($methods as $method) {
            if (!$method->isStatic() && $method->name !== '__construct') {
                $_methods []= $method->name;
            }
        }
        return $_methods;
    }

    /**
     * Returns true if the requested procedure is available on this service.
     *
     * @param $procedure
     * @return boolean
     * @throws \ReflectionException
     */
    public static function isProcedureCallable($procedure)
    {
        return in_array(camel_case($procedure), static::listProcedures());
    }



    /**
     * Return the name of the thrift service for this web service.
     *
     * @return string
     */
    public static function getThriftName()
    {
        return static::$thriftName;
    }

    /**
     * Return the service name used for the Thrift multiplexer.
     *
     * @return string
     */
    public static function getThriftServiceName()
    {
        return static::$thriftServiceName;
    }

    /**
     * Return the name of the Thrift processor class for this service.
     *
     * @return string
     */
    public static function getThriftProcessor()
    {
        return static::getThriftName() . 'Processor';
    }

    /**
     * Get the name of the Thrift client class for this service.
     *
     * @return string
     */
    public static function getThriftClient()
    {
        return static::getThriftName() . 'Client';
    }

    /**
     * Get the name of the REST client generated by Thrift.
     *
     * @return string
     */
    public static function getThriftRest()
    {
        return static::getThriftName() . 'Rest';
    }

    /**
     * Describe this service.
     *
     * @param array $options
     * @return mixed
     */
    public static function describeAsJson(array $options = [])
    {
        $descriptor = new JsonDescriptor;

        return $descriptor->describe(new static, $options);
    }

    /**
     * Return the configuration for this service.
     *
     * @return mixed
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Initialize the configuration for this service.
     *
     * @param array $config
     * @return mixed
     */
    public function initConfig(array $config)
    {
        $this->config = $config;
    }

    /**
     * Returns the status of this service.
     *
     * @return mixed
     */
    public function getStatus()
    {
        return $this->enabled;
    }

    /**
     * Returns true if this service is available in the same application container as the current application.
     *
     * @return boolean
     */
    public function isLocal()
    {

    }

    /**
     * Returns true if this service is not available in the same application container as the current application.
     *
     * @return boolean
     */
    public function isRemote()
    {
        // TODO: Implement isRemote() method.
    }

    /**
     * Get the configured endpoint.
     *
     * @return mixed
     */
    public function getEndpoint()
    {
        return isset($this->config['endpoint']) ? $this->config['endpoint'] : null;
    }

    /**
     * Set the endpoint.
     *
     * @param string $endpoint
     * @return mixed
     */
    public function setEndpoint($endpoint)
    {
        $this->config['endpoint'] = $endpoint;
    }

    /**
     * Pass the resource and any sub-resources through the transformer.
     *
     * @param $resource
     * @param $transformer
     * @param null $callback
     * @return mixed
     */
    protected function transform($resource, $transformer, $callback = null)
    {
        if (is_array($resource) || $resource instanceof \Traversable) {
            $result = [];
            foreach ($resource as $r) {
                if (is_callable($callback)) {
                    $r = $callback($r);
                }
                $result []= $this->transformResource($r, $transformer);
            }
            return $result;
        } else {
            if (is_callable($callback)) {
                $resource = $callback($resource);
            }
            return $this->transformResource($resource, $transformer);
        }
    }

    /**
     * Transform a single resource instance.
     *
     * @param $resource
     * @param $transformer
     * @return mixed
     */
    protected function transformResource($resource, $transformer)
    {
        if ($transformer instanceof Transformer) {
            return $transformer->transform($resource);
        } elseif (is_callable($transformer)) {
            return $transformer($resource);
        }

        throw new \InvalidArgumentException("Argument two must be an instance of Transformer or a callable closure.");
    }

}
